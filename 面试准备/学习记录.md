# JS

## 1. 基本数据类型

8种基本数据类型, 其中7种原始数据类型, number, bigint, string, null, undefined, boolean, symbol, 一种复杂数据类型, object



## 2. 类型转换

### **字符串转换**

 转换发生在输出内容的时候，也可以通过 `String(value)` 进行显式转换。原始类型值的 string 类型转换通常是很明显的。对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）
    来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。



### 数字型转换

转换发生在进行算术操作时，也可以通过 `Number(value)` 进行显式转换。

| 值             | 变成……                                                       |
| :------------- | :----------------------------------------------------------- |
| `undefined`    | `NaN`                                                        |
| `null`         | `0`                                                          |
| `true / false` | `1 / 0`                                                      |
| `string`       | “按原样读取”字符串，两端的空白会被忽略。空字符串变成 `0`。转换出错则输出 `NaN`。 |

```javascript
Number('a123') // NaN
Number('123z') // NaN
parseInt('a123') // NaN
parseInt('123a') // 123 // 允许存在非数字字符， 解析从左到右， 遇到非数字字符就停下来。
Number('') // 0
parseInt('') // NaN  
```



### 布尔型转换

转换发生在进行逻辑操作时，也可以通过 `Boolean(value)` 进行显式转换。

布尔型转换遵循以下规则：

| 值                                    | 变成……  |
| :------------------------------------ | :------ |
| `0`, `null`, `undefined`, `NaN`, `""` | `false` |
| 其他值                                | `true`  |



### == 的类型转换

常见的

```javascript
null == null
null == undefined
undefined == undefined
anything == NaN // false

```





## 3. 字符串拼接

### + 号什么时候用于字符串拼接

如果 + 的其中一个操作数是字符串（或者能转换为字符串）， 则执行字符串拼接， 否则执行数字加法

但是

```javascript
+'1' // 1
1 + '1'  // '11'

```



## 4. || 和 && 操作符的返回值

两个都会先对左边操作数进行条件判断

对于或来说， 如果左边为真， 则返回左边的操作数， 如果左边为假， 则返回右边的操作数

对于与来说， 如果左边为真， 则返回右边的操作数， 如果左边为假， 则返回左边的操作数

|| 和 && 返回它们其中一个操作数的值， 而非条件判断的结果



## 5. Symbol

> 1. let id = Symbol(‘id’)
> 2. 不能隐式字符串转换， 可以显示字符串转换 id.toString()
> 3. 在for…in, Object.keys() 中会被忽略



## 6. 内部属性[[class]]是什么

所有typeof 返回值为 ‘object’ 的对象, 都包含一个内部属性[[class]] , 可以视作内部的分类, 而非传统意义的面向对象的意思, 这个属性无法直接访问, 一般通过Object.prototype.toString.call(…) 来查看



## 7. typeof和instanceof

对于原始数据类型, 除了null, typeof都能正确显示类型, typeof null === ‘object’, 这是历史原因, 对于对象, 除了函数对象, typeof 都显示 ‘object’, 所以typeof并不能用来判断对象类型

instanceof 想判断一个对象的正确类型时, 用instanceof, 内部机制是通过原型链来实现的



## 8. this的指向问题

分几种情况

1. 当一个函数直接作为一个函数调用时， this指向全局对象
2. 当函数作为对象的方法调用时， this指向这个对象
3. 当函数作为构造函数被调用时， 函数执行前会新建一个对象， 函数内部的this指向这个对象
4. call， bind， apply 显示的指定函数内部的this指向
5. 箭头函数中的this指向为箭头函数创建时的代码块中的this的指向

优先级是构造函数>call,apply,bind,>方法调用，>函数调用



## 9. 什么是DOM和BOM

> DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。
>
> BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）
> 对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati
> on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对
> 象的子对象。



## 10. ==原型与原型链==(三座大山之一)

###  \_\_proto\_\_, [[Prototype]], F.prototype,

> [[Prototype]] 是对象的内部隐藏属性, 只能有一个, 一个对象不能从其他两个对象获得继承

> Object.getPrototypeOf, Object.setPrototypeOf, 是[[Prototype]]的getter/setter,

> \_\_proto\_\_ 是[[Prototype]]的历史的getter/setter, 但是观感较好, 它位于Obejct.prototype

> F.prototype 中的F指的是一个函数, 当F是一个构造函数时: F.prototype = someobj的意思是, 当调用 anotherObj = new F ==时==, 把anotherObj的[[Prototype]] 设置为someobj, F.prototype 仅在 new F 时被调用时使用, 它为新对象的[[Prototype]]赋值. 所有函数都有默认的prototype值, 是一个只有属性constructor的对象, 且值为函数本身, F.prototype = { constructor: F } 

> 基本数据类型的原型, 当访问字符串,数字,布尔值的属性时, 会调用临时包装器对它们进行包装, 用后就销毁. Null, undefined 没有对象包装器

### getter/setter

当getter在当前对象中没有找到值, 会顺着原型链找,

setter中this的指向是当前调用它的对象, 



### for…in , Object.keys(obj), Object.hasOwnProperty(key)

For… in 也会遍历继承的属性, 几乎所有其他键/值获取方法都忽略继承的属性

Object.keys(obj)只会返回obj自己的key

对于遍历, 只会弹出可枚举的属性, enumerable:true; 

 obj.hasOwnProperty(key), 不会顺着原型链找key



###  Object.getPrototypeOf, Object.setPrototypeOf, Object.create, 设置和直接访问原型的现代方法

> Object.getPrototypeOf, Object.setPrototypeOf, 是[[Prototype]]的getter/setter,

> Let rabbit = Oject.create(animal) // 创建一个以animal为原型的对象
>
> Object.create(proto, [descriptors]) —— 利用给定的proto作为[[Prototype]] 和可选的属性描述来创建一个空对象, 关于[属性描述](https://zh.javascript.info/property-descriptors)



### JS获取原型的方法

p.\_\_proto\_\_

p.constructor.prototype

Object.getOwnPrototype(p)



## 11. JS的整数的安全范围

[2 ** 53 - 1, -(2**53-1)]

因为js以64位浮点数存放数值, 64位浮点数的后52位用于存放整数, 而2**53 = 1..52个0…., 



如果计算过程中, 一个结果超过了范围, 结果会变成Infinity, 可用isFinite来判断是不是Infinity值





## 12. ==异步==(三座大山之二)

### 实现方式

> 1. 回调函数
> 2. 事件监听
> 3. 观察者模式
> 4. Promise
> 5. Generator, 但是generator的正途应该是作为特殊的迭代器。
> 6. async



### Promise

一个解决回调地狱的方法, 可以视为起到将生产者和消费者连接在一起的作用

> let promise = new Promise(function(resolve, reject){
>
> ​	// 生产者代码(executor)
>
> ​	// 在这之中, 只有第一个resolve或者reject有效, 后面的会被忽略, 保持只有一个结果的原则
>
> })

> then, catch, finally 消费者(handler), 都是异步的
>
> then(function(result){}, function(error){})
>
> Catch 是 then(null, function(error))的另一种写法
>
> finally, promise 有三种状态, pending, resolved, rejected, 当处于resolved或者rejected时, 称为settled, finally在promisesettled后执行, finally不会捕获结果, 会把结果传递给它后面的消费者
>
> 如果handler中return一个值, 会被Promise.resolve()包装, 如果return一个promise, 则后面的消费者会等待这个promise的结果.

> 错误处理:
>
> 在promise的executor 和handler中, 以reject() 或者 throw new Error()的方式抛出的错误会被捕获, 并将其变为rejected promise, 这个错误会被传递到距离最近的错误处理程序, 在错误处理程序中还可以rethrow, 错误会继续沿着promise链传递. 如果错误没有被处理, 最后就变成全局的error

> Promise 的api
>
> Promise.all([…promises…]) 接收一个包含promise的可迭代对象, 当其中所有的promise都settled时, 新的promise才被resolve, 其结果数组成为新的promise的结果, 如果任意一个promise被reject, 则由Promise.all返回的promise就会立即reject, 并且带有的就是这个error, 其他promise的结果被忽略. 可迭代对象中非promise的值会被放在数组中原样返回
>
> Promise.allSettled(), 如果不管promise被resolve, 还是reject, 都要全部的结果,就用Promise.allSettled(), 其结果数组有{status: ‘fulfilled’, value: result}, {status: ‘rejected’, reason: error }, 
>
> ```javascript
> // Promise.allSettled() polyfill
> if(!Promise.allSettled){
>   Promise.allSettled = (promises) => Promise.all(
>   	promises.map(promise => Promise.resolve(promise).then(result => ({status: 'fulfilled', value: result})).catch(error => ({statue: 'rejected', reason: error}))
>   )
> }
> ```
>
> Promise.race, 只等待第一个settled的promise,不管是resolved,还是error
>
> Promise.resolve, Promise.reject,用其参数创建一个resolved的promise

> Async/await
>
> 一种以更舒适的方式使用promise的语法
>
> ```javascript
> // Async 放在函数面前表达这个函数总是返回一个promise, 其他值将自动被包装在一个resolved的promise中
> async function f() {
>   return 1;
> }
> 
> // await 用于等待其后的promise settle, 并返回结果, 如果是reject, 会抛出错误, await只能用在async 函数中
> let value = await promise;
> 
> // await 还可以接收带 .then 方法的对象, 它会调用.then方法, 给传两个参数(resolve, reject)
> // https://zh.javascript.info/async-await
> ```
>
> 
>
> 
>
> 



### generator

> 常规函数只能放回单一值, 而generator可以按需的一个一个的yield多个值, 可以与iterable配合使用, 从而创建数据流
>
> ```
> function *foo(x) {
>   let y = 2 * (yield (x + 1))
>   let z = yield (y / 3)
>   return (x + y + z)
> }
> let it = foo(5)
> console.log(it.next())   // => {value: 6, done: false}
> console.log(it.next(12)) // => {value: 8, done: false}
> console.log(it.next(13)) // => {value: 42, done: true}
> ```
>
> 你也许会疑惑为什么会产生与你预想不同的值，接下来就让我为你逐行代码分析原因
>
> - 首先 `Generator` 函数调用和普通函数不同，它会返回一个迭代器
> - 当执行第一次 `next` 时，传参会被忽略，并且函数暂停在 `yield (x + 1)` 处，所以返回 `5 + 1 = 6`
> - 当执行第二次 `next` 时，传入的参数等于上一个 `yield` 的返回值，如果你不传参，`yield` 永远返回 `undefined`。此时 `let y = 2 * 12`，所以第二个 `yield` 等于 `2 * 12 / 3 = 8`
> - 当执行第三次 `next` 时，传入的参数会传递给 `z`，所以 `z = 13, x = 5, y = 24`，相加等于 `42`



### 事件循环 event loop

js 是一门单线程语言

event loop是js的执行机制

> 一个在等待任务, 执行任务, 休眠这几个状态之间转换的无限循环
>
> 简化的步骤: 
>
> 1. 从宏任务队列出队一个任务, 并执行
> 2. 执行微任务队列中的所有任务
> 3. 如果有渲染, 执行渲染
> 4. 如果有宏任务队列为空, 进入休眠等待任务
> 5. 跳到步骤1

> 宏任务队列来源:
>
> setTimeout
>
> setInterval
>
> setImmediate
>
> I/O
>
> UI rendering

> 
>
> 微任务队列
>
> 来源:
>
> 1. promise 的handler
> 2. process.nextTick(callback), 把callback, push到微任务队列
> 3. Object.observe
> 4. MutationObserver





## 13. ==闭包==（三座大山之三）

### 定义

闭包一般指内部函数总是可以访问外部函数中的变量和参数，即使外部函数的寿命已经结束。

### 词法环境

> step 1: 变量
>
> js中每一个代码块都有一个词法环境， 可以把它视作一个内部隐藏的规范对象：它仅仅存在于编程语言规范。
>
> 词法环境包含两个部分， 1： 环境记录，一个存储所有局部变量作为其属性的对象。 2：outer：对外部词法环境的引用， 与外部代码相关联。
>
> 在代码块开始执行时， 词法环境会预先填充该代码块中所有声明的变量， 最初这些变量处于uninitialized状态，就是引擎知道这些变量的存在， 但是在变量被声明前无法引用。 从代码块的开始到变量的声明这一段称为==暂时性死区==。 从变量被声明后，就可以使用变量了。
>
> step 2: 函数声明
>
> 不同于变量死区， 在代码块开始执行时， 函数声明的初始化会立即完成， 变成可用状态， 这也是为什么可以在函数声明前调用函数。 正常来说，这种行为只适用于函数声明， 而不适用与将函数分配给变量的函数表达式。 例如 let say = function(name){...}
>
> step 3: 内部和外部的词法环境
>
> 在一个函数声明或创建时，会创建一个词法环境， 可以先称为该函数的内部词法环境， 该内部词法环境的outer会指向声明或者创建该函数的代码块的词法环境（外部词法环境）。当函数内部代码访问一个变量时， 会先从内部词法环境寻找， 找不到就到外部词法环境寻找， 再找不到就再到更外部的词法环境寻找。也就是说所有的函数在诞生时都会记住创建它们的词法环境，所有函数都有名为[[Environment]]的隐藏属性， 该属性在函数创建时被设置指向外部词法环境， 并永久保存。

### 用途

> 可以用来创建私有变量
>
> 可以使外部词法环境中的变量保留在内存中，因为闭包函数保留了这些变量的引用。所以变量不会被回收。



## 14. 手写JS

### 1. 手写Promise

[手写promise](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/JavaScript/JavaScript.md#137-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-promise)

```javascript
const PENDING = "pending";
RESOLVED = "resolved";
REJECTED = "rejected";

function MyPromise(fn) {
  const self = this; // 保存this指向
  this.state = PENDING;
  this.value = null;
  this.resolvedCallbacks = []; // resolve后的callback
  this.rejectedCallbacks = [];

  function resolve(value) {
    if (value instanceof MyPromise) {
      // 如果是个promise, 需要等这个promise执行完
      return value.then(resolve, reject);
    }

    setTimeout(() => {
      // 需要异步执行回调
      if (self.state === PENDING) {
        self.state = RESOLVED;
        self.value = value;
        self.resolvedCallbacks.forEach((callback) => callback(value));
      }
    }, 0);
  }

  function reject(value) {
    setTimeout(() => {
      if (self.state === PENDING) {
        self.state = REJECTED;
        self.value = value;
        self.rejectedCallbacks.forEach((callback) => callback(value));
      }
    });
  }

  try {
    fn(resolve, reject); // 执行executor, 出现错误就reject
  } catch (err) {
    reject(err);
  }
}

MyPromise.prototype.then = function (onResolved, onRejected) {
  const self = this;

  // 如果不是函数就进行替换
  onResolved = typeof onResolved === "function" ? onResolved : (v) => v;
  onRejected =
    typeof onRejected === "function"
      ? onRejected
      : (v) => {
          throw v;
        };

  if (self.state === PENDING) {
    return (promise2 = new MyPromise((resolve, reject) => {
      // .then 总是返回一个promise,
      self.resolvedCallbacks.push(() => {
        // 对onResolved 进行包装
        try {
          const x = onResolved(self.value);
          resolve(x);
        } catch (err) {
          reject(err);
        }
      });

      self.rejectedCallbacks.push(() => {
        try {
          const x = onRejected(self.value);
          resolve(x);
        } catch (err) {
          reject(err);
        }
      });
    }));
  }

  if (self.state === RESOLVED) {
    return (promise2 = new MyPromise((resolve, reject) => {
      self.resolvedCallbacks.push(() => {
        try {
          const x = onResolved(self.value);
          resolve(x);
        } catch (err) {
          reject(err);
        }
      });
    }));
  }

  if (self.state === REJECTED) {
    return (promise2 = new MyPromise((resolve, reject) => {
      self.rejectedCallbacks.push(() => {
        try {
          const x = onRejected(self.value);
          resolve(x);
        } catch (err) {
          reject(err);
        }
      });
    }));
  }
};

const myp = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve(1);
  }, 1000);
});

myp
  .then((x) => {
    console.log(x);
    return x * 2;
  })
  .then((x) => {
    console.log(x);
    return x * 2;
  });

```



### 2. 防抖与节流

> 防抖: 使一个函数在n秒后再执行， 如果在n秒内， 函数又被调用， 则重新计时
>
> 用途： 可用于一些点击请求的事件上， 防止用户短时间内的多次点击向服务器发送多次请求, 或者搜索框的键入实时提示，
>
> ```javascript
> function debounce(fn, delay){
>   let timer = null;
>   return function(){
>     let context = this
>     let args = arguments
>     if(timer){
>       clearTimeout(timer)
>       timer = null
>     }
>     timer = setTimeout(()=>{
>       fn.apply(context, args)
>     }, delay)
>   }
> }
> ```

> 节流：使函数在n秒内只能执行一次， 在n秒内，被调用超过两次的直接忽略
>
> 用途： 可用于频繁触发的事件， 如scroll事件, 减少事件回调函数的执行次数， 或者跟踪鼠标
>
> ```javascript
> function throttle(fn, delay){
> 	let isThrottled = false,
>       savedThis,
>       savedArgs;
>   
>   function wrapper(){
>     if(isThrottled){
>       savedThis = this
>       savedArgs = arguments
>       return
>     }
>     isThrottled = true
>     fn.apply(this, arguments)
>     setTimeout(() => {
>       isThrottled = false
>       if(savedThis){
>         wrapper.apply(savedThis, savedArgs)
>         savedThis = savedArgs = null
>       }
>     }, delay)
>   }
>   return wrapper
> }
> ```



### 3. 深拷贝、浅拷贝

> 考这个其实就是看你知不知道指针的概念

> 浅拷贝的实现：
>
> 只适用于对象的浅拷贝
>
> ```javascript
> function shallowCopy(obj){
>   if(!obj || typeof obj !== 'object') return null
>   const newObj = {}
>   for(let key of Object.keys(obj)){
>     newObj[key] = obj[key]
>   }
>   return newObj
> }
> 
> // 或者直接
> newObj = Object.assign({}, obj)
> newObj = {...obj}
> 
> ```

> 深拷贝的实现：
>
> 这里只是简单实现
>
> 真的实现还要考虑到Promise,dom元素等的处理
>
> ```
> function deepCopy(obj){
> 	if(!obj || typeof obj !== 'object') return null
> 	const newObj = {}
> 	for(let key of Object.keys(obj)){
> 		newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]
> 	}
> 	return newObj
> }
> ```
>
> 



### 4. 柯里化、currying

> 将一个以f(a, b, c) 方法调用的函数变成 f(a)(b)(c) 的方式调用， 其实也可以变成f(a, b)(c)， 看具体应用
>
> 用途参数复用， 降低通用性， 提高了复用性
>
> ```javascript
> function currying(fn) {
>   return function carry(...args) {
>     if (args.length >= fn.length) {
>       return fn.apply(this, args);
>     } else {
>       return function (...args1) {
>         return carry.apply(this, args.concat(args1));
>       };
>     }
>   };
> }
> ```
>
> 



### 5. 偏函数， partial

> 返回一个预先绑定了一些参数的函数
>
> 
>
> ```javascript
> function partial(fn, a){
>   return function(b,c){
>     return fn(a,b,c)
>   }
> }
> 
> // 或者利用bind
> fn.bind(null, a)
> ```
>
> 



### 6. bind, apply, call 

> 三个api的第一个参数都是为函数的内部指定this的指向
>
>  
>
> ```javascript
> // call
> Function.prototype.myCall(context){
>   if(typeof this !== 'function'){
>     throw new TypeError('error')
>   }
>   context = context || window
>   const fn = this
>   const args = [...arguments].slice(1)
>   context.fn = fn 
>   let result 
>   result = context.fn(...args)
>   delete context.fn
>   return result
> }
> 
> // apply
> Function.prototype.myApply(context){
>   if(typeof this !== 'function'){
>     throw new TypeError('error')
>   }
>   context = context || window
>   context.fn = this
>   const args = arguments[1] ? [...arguments[1]] : []
>   const result = context.fn(...args)
>   delete context.fn
>   return result
> }
> 
> // bind
> Function.prototype.myBind(context){
>   if(typeof this !== 'function'){
>     throw new TypeError('error')
>   }
>   const fn = this
> 	const args = [...arguments].slice(1)
>   // 返回一个函数
>   return function F(...args1){
>     // 因为返回了一个函数， 可以new F() 所以需要判断
>     if(this instanceof F){	// 如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象
>       return new fn(...args, ...args1)
>     }else{
>       return fn.apply(context, args.concat(args1))
>     }
>   }
> }
> 
> 
> ```
>
> 

### 7. 写一个通用的事件监听器函数

```javascript
const EventUtils = {
  addEvent(element, type, handler){
    if(element.addEventListener){		// dom2 方式 
      element.addEventListener(type, hanlder)
    }else if(element.attchEvent){		// ie
      element.attachEvent('on' + type, handler)
    }else{
      element['on' + type] = handler 		// dom0方式 elem.onclick = ...
    }
  },
  
  removeEvent(element, type, handler){
    if(element.removeEventListener){
      element.removeEventListener(type, handler)
    }else if(element.detachEvent){
      element.detachEvent('on' + type, handler)
    }else {
      element['on' + type] = null
    }
  },
  
  getTarget(e){
    return e.target || e.srcElement
  },
  
  getEvent(e){
    return e || window.event
  },
  
  // IE 只支持事件冒泡
  stopPropagation(e){
    if(e.stopPropagation){
      e.stopPropagation()
    } else {
      e.cancelBubble = true;
    }
  },
  
  preventDefault(e){
    if(e.preventDefault){
      e.preventDefault()
    } else {
      e.returnValue = false;
    }
  }
}
```



### 8. Instanceof

```javascript
function myInstanceof(left, right){
  let proto = Object.getPrototypeOf(left),
  while(proto){
    if(proto === right.prototype){
      return true
    }
    proto = Object.getPrototypeOf(proto)
  }
  return false
}
```



### 9. new 操作符

> new操作符的作用
>
> 1. 新建一个对象
> 2. 使函数内部的this指向为这个新对象
> 3. 设置对象的原型为构造函数的prototype
> 4. 判断函数返回值，如果为对象或者函数，则直接返回， 如果不是则返回新建对象
>
> ```javascript
> // objectFactory(构造函数， 构造参数)
> function objectFactory(){
>   let newObject = null,
>       result = null,
>       constructor = argument[0];
>   if(!constructor || typeof constructor !== 'function'){
>     throw new TypeError('error')
>   }
>   newObject = Object.create(constructor.prototype)
>   result = constructor.apply(newObject, arguments[1] ? arguments[1] : [])
>   let flag = result && (typeof result === 'object' || typeof result === 'function')
>   return flag ? result : newObject;
> }
> ```
>
> 



### 10. xhr

> ```javascript
> function getJSON(url){
>   return new Promise((resolve, reject) => {
>     const xhr = new XMLHttpRequest();
>     xhr.open('GET', url, true);
>     xhr.onreadystatechange = function(){
>       if(this.readyState !== 4) return 
>       if(this.status === 200){
>         resolve(this.response)
>       }else{
>         reject(new Error(this.statusText))
>       }
>     }
>     xhr.onerror = function(){
>       reject(new Error(this.statusText))
>     }
>     
>     xhr.responseType = 'json'
>     xhr.setRequestHeader('Accept', 'application/json')
>     xhr.send(null)
>   })
> }
> ```
>
> 



### 11. JS 原生实现拖拽

> 1. mousedown时记下偏移量，绑定后续函数，设置元素位置，初始移动
> 2. mousemove移动元素
> 3. mouseup清理
> 4. 阻止ondragstart的默认行为

```javascript
ball.onmousedown = function(e){
  let shiftX = e.clientX - ball.getBoundingClientRect().left,
      shiftY = e.clientY - ball.getBoundingClientRect().top
  
  function moveAt(clientX, clientY){
    ball.style.left = clientX - shiftX + 'px';
    ball.style.top = clientY - shiftY + 'px';
  }
  
  function onMouseMove(e){
    moveAt(e.clientX, e.clientY)
  }
  
  function onMouseUp(e){
    document.removeEventListener('mousemove', onMouseMove)
    ball.onmouseup = null
  }
  
  ball.style.position = 'fixed'
  ball.style.zIndex = 1000;
  
  document.addEventListener('mousemove', onMouseMove)
  ball.onmouseup = onMouseUp
  
  moveAt(e.clientX, e.clientY)
}

ball.ondragstart = function(){
  return false;
}
```



### 12. 使用setTimeout实现setInterval

> setInterval的问题， setInterval时间到了，并不是马上执行，而是把任务提交到了宏任务队列， 如果队列前面的任务阻塞了挺久的， 那么setInterval可能会不断的往宏任务队列中添加任务， 这就造成了，等排队排上的时候， 那些任务会直接按顺序执行， 而没有间隔一段时间的效果。 还有一个原因就是setInterval没有考虑到回调函数自身运行的时间， 就是说，即使回调函数在提交后立马运行，但是setInterval也是马上就开始重新开始计时了。 可以用setTimeout来实现setInterval，从而达到只有上一个任务执行完毕， 才重新向宏任务队列新提交一个任务
>
> ```javascript
> function myInterval(fn, interval){
>   let timer = {flag: true} // flag控制停止
>   function wrapper(){
>     if(timer.flag){
>       fn()
>       setTimeout(wrapper, interval)
>     }
>   }
>   setTimeout(wrapper, interval)
>   return timer
> }
> ```
>
> 



### 13.封装一个js的类型判断函数

```javascript
function getType(value){
  if(value === null){
    return 'null'
  }
  if(typeof value === 'object'){
    let s = Object.prototype.toString(value)
    s = s.split(' ')[1].split('')
    s.pop()
    return s.join('').toLowerCase()
  }
  return typeof value
}
```



### 14. 用闭包实现每隔一秒打印1， 2， 3， 4，

```javascript
function outer(){
  let cnt = 1
  function inner(){
    console.log(cnt)
    setTimeout(() => {
      inner()
    }, 1)
  }
  inner()
}
```



### 15. JSONP

```javascript
function jsonp(url, params, callback){
  if(!url || !callback){
    throw new Error('url and callback are required')
  }
  
  if(params && Object.keys(params)){
    url += '?'
    for(let key of Object.keys(params)){
      url += key + "=" + params[key] + '&'
    }
  }
  
  let myCallbackName = 'mycallbackname' + Math.random().toString().replace('.', '')
  url += 'callback=' + myCallbackName
  
  let script = document.createElement('script')
  script.src = url
  
  window[myCallbackName] = function(...args){
    callback(...args)
    document.body.removeChild(script)
  }
  
  document.body.appendChild(script)
}
```



### 16. 扁平化

```javascript
// 扁平化数组 [1, [2, [3, 4]]]

function flatten(nums){
  let ans = []
  for(let item of nums){
    if(Array.isArray(item)){
      ans = ans.concat(flatten(item))
    }else{
      ans.push(item)
    }
  }
  return ans
}

function flatten(nums){
  return nums.reduce((prev, cur) => prev.concat(Array.isArray(cur) ? flatten(cur) : cur)), []
}
```



## 17. 倒计时校准， 纠偏，

```javascript
let interval = 1000
let leftTime = 30000
let cnt = 0
let timer = null
let startTime = null
if(leftTime > 0){
  startTime = Date.now()
  timer = setTimeout(countDown, interval)
}

function countDown(){
  cnt += 1
  let offset = Date.now() - (startTime + cnt * interval)
  let newInterval = interval - offset
  if(newInterval < 0){
    newInterval = 0
  }
  console.log(`误差${offset}秒`)
  leftTime -= interval
  if(leftTime > 0){
    timer = setTimeout(countDown, newInterval)
  }else{
    clearTimeout(timer)
  }
}
```











## 15. 常用api

```javascript
// js
Math.random()  // [0, 1)
Math.round(num) // 四舍五入
Math.floor(num)
Math.ceil(num)

//Array
forEach, map, join, pop, push, shift, unshift, slice, splice, reduce, concat, reverse, filter, sort, every, some, indexOf, lastIndexOf,fill


//dom
// 创建新节点
createDocumentFragment(node);
createElement(node);
createTextNode(text);

//
appendChild(node)
removeChild(node)
replaceChild(new, old)
insertBefore(new, old)

getElementById()
getElementsBy(Name|TagName|ClassName)
querySelector()
querySelectorAll()

getAttribute(key);
setAttribute(key, value);
hasAttribute(key);
removeAttribute(key);
```



## 16. 事件模型

> 三种事件模型：
>
> 1. DOM0, 最早的模型， 所有浏览器都兼容， 通过elm.onclick = … 方式来设置， 不能为同一类型事件设置多个处理程序
> 2. IE事件模型， 只有处理阶段和冒泡阶段，通过elm.attachEvent(‘on’ + type, handler), elm.detachEvent(‘on’+type, handler)
> 3. DOM2事件模型， 有捕获，处理， 冒泡阶段， 通过elm.addEventListener(type, handler), elm.removeEventListener(type, handler)



## 17. 事件的冒泡与捕获

> 当事件发生时：
>
> 1. 引发事件的那个嵌套最深的那个元素被设为e.target
> 2. 事件从文档根节点，一步步向下到达e.target, 过程中调用使用addEventListener(…, {capture: true})添加的事件处理程序
> 3. 到达e.target后， 调用该元素上所有的相应的事件处理程序， 按添加顺序执行
> 4. 再从e.target向上冒泡， 一步步到达文档根节点， 过程中调用 使用 on<event>, 或者addEventListener没有第三个参数， 或者capture为false的事件处理程序
>
>  
>
> e.target : 引发事件的嵌套最深的那个元素
>
> e.currentTarget: 当前调用事件处理程序的元素
>
> e.eventPhase: 当前阶段(capturing=1, target=2, bubbling=3)



## 18. 事件委托

> 因为事件可以冒泡， 可以把子元素的事件处理程序放在父元素上， 这样子不用为每个子元素都添加一个事件处理程序， 可以节省内存，而且，如果我们动态的添加子元素， 也不用再为这个子元素添加事件处理程序



## 19. js延迟加载的方式有哪些

> js的加载，解析，执行过程会阻塞页面的渲染过程， 因此我们希望js脚本能够尽可能的延迟加载，提高页面的渲染速度
>
> 1. 将script标签放在文档底部，使js脚本尽可能的在最后来加载执行
> 2. 使用script标签的defer属性，defer属性使这个脚本的加载与解析与文档的解析同步， 但是要等文档解析完成才能执行，多个defer的执行顺序，按规范应该是按顺序的，但是要看具体浏览器
> 3. 使用script标签的async属性，async属性使脚本异步加载， 但是脚本一加载完成就会立马执行，如果文档还没解析完成， 就会被阻塞， 多个async的执行顺序， 无法预知
> 4. 动态的添加script标签， 对文档的加载事件进行监听， 等文档加载完成再动态的创建script标签

## 20. Ajax

> ajax 是一种异步通信的方法， 使js可以直接向服务器请求数据， 然后根据数据更新网页， 而不用刷新整个页面
>
> 原生js创建ajax的方法是
>
> 1. new 一个XmlHttpRequest对象
> 2. open(method, url,是否异步)
> 3. 设置onreadystatechange, onerror的处理函数
> 4. send



## 21. 浏览器缓存机制

[完整版](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/JavaScript/JavaScript.md#56-%E8%B0%88%E4%B8%80%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6)

> 缓存机制是指通过将一些请求到的web资源缓存在本地，在缓存资源的有效期内，对该资源的请求会直接使用缓存的内容，而不用再从服务器获取。
>
> 缓存有两种策略， 强缓存策略， 协商缓存策略
>
> 强缓存策略：
>
> 服务器通过响应头的cache-control设置， max-age表示缓存的寿命， private表示只能由浏览器缓存， 不能被代理服务器缓存， no-cache代表可以缓存但是立刻失效，对资源的请求需要从新获取
>
> 协商缓存策略 2种方式：
>
> 服务器通过响应头设置last-modified= x， 浏览器请求时带上if-modified-since =x, 来询问服务器，服务器判断资源是否被修改， 如果没有则返回304，告诉浏览器可以直接返回缓存，如果修改过则返回修改过的资源
>
> 2. 服务器在响应头上带上资源的唯一标识符etag， 浏览器请求时带上etag，服务器进行判断，看返回304还是新资源， 但是如果服务器弄了负载均衡之类的， 多台服务器上的etag不一样，就最好不要用etag
>
> 实际应用：
>
> 强缓存策略和协商缓存策略一起用：
>
> 浏览器请求时， 如果强缓存策略命中，则直接使用，否则就跟服务器进行协商。

> get/post在缓存方面的区别
>
> 缓存一般适用于不会对服务器数据造成修改的请求，而get一般就是用来做不会对服务器造成修改的请求， post一般用来做会对服务器造成修改的请求， 所以对get请求做缓存比较常见， 对post请求做缓存很少见。



## 22. 什么是同源策略

> 同源：协议，域名，端口号都相同
>
> 一个域下的js在未经允许的情况下，不能访问另一个域的内容，比如
>
> 1. 不能访问其他域的cookie， localStorage，indexDB
> 2. 不能操作其他域的DOM
> 3. ajax不能发送跨域请求
>
> 这样做是为了保护用户的信息安全， 但是img， script等的没有跨域的限制，这些操作的响应结果不会直接导致安全问题



## 23. 如何解决跨域问题

https://segmentfault.com/a/1190000011145364

[如何解决跨域问题](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/JavaScript/JavaScript.md#60-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98)

> 解决跨域问题要按目的来划分
>
> 如果要实现主域名下的不同子域名的跨域操作，可以使用设置document.domain来解决
>
> 如果要实现不同跨域窗口间的通信问题， 比如说一个页面要和页面中的不同源的iframe通信，可以通过postMessage api来实现。
>
> 如果要解决ajax无法请求跨域资源的问题， 可以使用jsonp， cors（跨域资源共享），服务器代理等来解决问题
>
> jsonp: 通过script标签没有跨域问题的特性来实现的， 动态的创建一个sript标签， src是一个带参网址， 参数可以是一个回调函数的名字，这种方式只支持get
>
> cors：对于普通的跨域请求只需要服务端设置access-control-allow-origin即可， 如果要带cookie则前端也要设置，如xhr.withCredentials=true，
>
> nginx: 配置proxy_pass等反向代理相关参数



## 24. cookie

> 我的理解是cookie主要是用来维持会话状态信息的数据，对于那些每次请求都要携带的信息就比较适合放在cookie中, 一般一个cookie大小为4kb， 可以有20个cookie，但是还是看浏览器具体实现。
>
> cookie可以通过服务器返回响应头的set-cookie,或者js的document.cookie设置。
>
> cookie有5个属性比较重要
>
> 1. max-age， 代表cookie的寿命
> 2. domain/path, 用来指明哪些请求要带上cookie信息， ajax除外，ajax默认不带cookie，要经过设置，xhr.withCredentials=true。只有请求的域名是domain或domain的子域名，且路径是path或path的子路径，才会带上cookie
> 3. secure， 指明是否只在安全的协议中带上cookie， 如https这种带加密的安全协议
> 4. httpOnly, 表明cookie只能通过服务器设置，不能通过js访问



## 25. 对模块化的看法

> 模块是实现一个特定功能的一组方法，在最开始的时候，js只实现一些简单的功能，所以并没有模块的概念， 但随着程序越来越复杂， 代码的模块化开发变得越来越重要。可以将几个函数作为一个模块， 也可以将几个函数放在一个对象里，把这个对象当成一个模块，还可以通过闭包， 来实现模块， 闭包还有个好处就是模块可以拥有私有作用域。



## 26. 对es6中class的看法

> 在我看来class的加入是为了补充js所缺少的面向对象的特性，使用class可以方便我们更好的组织代码， class本质上是语法糖， 是通过原型继承来实现的，在class中添加的函数， 其实是添加到了类的原型上了。



## 27. innerHTML, outerHTML, innerText, outerText

> “<div>something<br\><\div>“
>
> innerHTML: something<br\>
>
> outerHTML: <div>something<br\><\div>
>
> innerText: something
>
> outerText: something



## 28. 什么是类数组对象

> 一个拥有length属性， 和若干索引项的对象就可以称为类数组对象， 常见的有， arguments， 查找dom元素方法放回的结果等， 可以通过Array.from(arrayLike)，来转换为数组



## 29. 关于var跟变量提升

[旧时的 "var"](https://zh.javascript.info/var)

> 1. var只有全局作用域跟函数作用域
> 2. 可以在var声明前使用变量， 这称为变量提升， 但是赋值没有被提升
> 3. var可以重新声明
> 4. 使用var声明的全局函数跟变量会被添加到window对象上

> 而let，const：
>
> 1. 只在声明的代码块中有效
> 2. 不存在声明提升
> 3. 在声明前为暂时性死区
> 4. 不允许重复声明





## 30. 如何判断当前脚本运行在浏览器中还是node环境中

> this === window ? ‘browser’ : ’node’;
>
> 通过判断global对象是不是window，是就是浏览器， 不是就是node



## 31. 移动端的点击事件的延迟

 [《移动端 300ms 点击延迟和点击穿透》](https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0)

> 移动端有双击缩放的功能，所以需要一段延时来检测， 延时时间是300ms
>
> 有3个办法解决
>
> 1. 通过meta标签禁止缩放
> 2. 通过meta标签将viewport设置为ideal viewport
> 3. 调用一些js库， 比如FastClick
>
> ```
> click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。
> ```



## 32. 前端路由

> 传统的web开发， 路由是由后端控制的， 前端url的变化，会导致页面刷新， 浏览器向后端发起请求， 然后后端根据url返回不同的页面。
>
> 而前端路由，就是说，让前端自己根据url的变化来显示不同的ui，前端路由有两种方式：
>
> 1. 基于hash的方式：
>
>    原理是url的hash值变化不会导致浏览器刷新页面， 且hash值变化会触发hashchange事件， 通过对location.hash的存取，可以改变hash， 也会触发hashchange事件。
>
> ```html
> <div>
>   <ul>
>     <li><a href='#hahaha'>hahaha</a></li>
>     <li><a href='#wahaha'></a></li>
>   </ul>
>   <div id='root'>
>     
>   </div>
> </div>
> ```
>
>  
>
> ```javascript
> window.addEventListener('DOMContentLoaded', onLoad);
> window.addEventListener('hashchange', onHashChange);
> 
> let root = null;
> 
> function onLoad(){
>   root = document.getElementById('root')
>   onHashChange()
> }
> 
> function onHashChange(){
>   const hash = location.hash
>   switch(hash){
>     case '#hahaha':{
>       root.innerText='hahaha'
>       break
>     }
>     case '#wahaha': {
>       root.innerText='wahaha'
>       break
>     }
>     default: return
>   }
> }
> ```
>
>  
>
> 2.  基于html5中history的新api， pushState， replaceState，还有popstate事件，通过pushState跟replaceState修改url不会导致页面刷新， 但是手动的调用pushState跟replaceState跟a标签不会触发popstate事件， 不过可以对pushState跟repalceState进行包装， 对a标签进行包装添加点击事件来解决
>
>  ```javascript
> window.addEventListener('DOMContentLoaded', onLoad);
> window.addEventListener('popstate', onPopState);
> 
> let root = null;
> 
> function onLoad(){
>   root = document.getElementById('root')
>   onPopState()
>   let links = document.querySelectorAll('a[href]')
>   links.forEach(a => {
>     a.addEventListener('click' , (e) => {
>       e.preventDefault()
>       history.pushState(null, null, a.getAttribute('href'))
>       onPopState()
>     })
>   })
> }
> 
> function onPopState(){
>   const path = location.pathname
>   switch(hash){
>     case '/hahaha':{
>       root.innerText='hahaha'
>       break
>     }
>     case '/wahaha': {
>       root.innerText='wahaha'
>       break
>     }
>     default: return
>   }
> }
>  ```
>
>  
>
> react版实现
>
> ```html
> <HistoryRouter>
>   <Link to='/home'>home</Link>
>   <Link to='/about'>about</Link>
>   <Route path='/home' render={() => <h2>
>     home
>     </h2>} />
>   <Route path='about' render={() => <h2>
>     about
>     </h2>} />
> </HistoryRouter>
> ```
>
> 
>
> ```javascript
> 
> import React from 'react';
> 
> const MyContext = React.createContext()
> 
> class HistoryRouter extends React.Component{
>   state = {curPath: window.location.path}
> 
> 	onPopState = () => {
>     this.setState({
>       curPath: window.location.path
>     })
>   }
>   
>   componentDidMount(){
>     window.addEventListener('popstate', this.onPopState)
>   }
> 	
> 	componentWillUnMount(){
>     window.removeEventListener('popstate', this.onPopState)
>   }
> 
> 	render(){
>     return (
>     	<MyContext.Provider value={{curPath: this.state.curPath, onPopState: this.onPopState}}>
> 				{this.props.children}
>       </MyContext.Provider>
>     )
>   }
> }
> 
> function Route({path, render}){
>   return (
>   	<MyContext.Consumer>
>     	{({curPath}) => curPath === path ? render() : null}
>     </MyContext.Consumer>
>   )
> }
> 
> function Link({to, ...props}){
>   return (
>   	<MyContext.Consumer>
>     	{({onPopState}) => (
>   		<a href={to} {...props} onclick={(e) => {
>    		 	e.preventDefault;
>     		window.pushState(null, '', to);
>     		onPopState
>   		}}></a>
>   		)}
>     </MyContext.Consumer>
>   )
> }
> 
> ```
>
> 



## 33. =\= , \=\==, Object.is()

> 双等号会进行类型转换
>
> 三等号不会进行类型转换
>
> Object.is跟三等号基本相同， 处理了一些特殊情况，-0跟+0不相等， 两个NaN相等。



## escape, encodeURI, encodeURIComponent

https://www.zhihu.com/question/21861899

> 编码范围不一样， 决定了它们的应用场景不一样
>
> escape: 用于编码整个字符串， 不适用于编码url
>
> encodeURI: 适用于编码整个url
>
> encodeURIComponent：适用于编码url中的参数
>
> 



## Unicode， UTF-8的关系

> Unicode 是一个字符集合， 每一个字符对应一个二进制代码， 它只规定了字符的二进制代码， 却没有规定二进制代码如何被编码传输
>
> utf-8是unicode的一种编码方式， 它是一种变长的编码方式， 可以用1-4个字节来表示一个字符。



## 36. 0.1 + 0.2 !== 0.3 

> js使用双精度浮点数来存储数字， 所以上面的问题主要原因就是精度问题， 因为0.1跟0.2用2进制表示时就像无理数一样， 比如10进制下的1/3，所以导致了精度的问题。
>
> 解决方法的话
>
> 1. 对所有的小数都乘以一个相同的整数， 再对结果除以一个相同的整数，再进行比较， 简称乘除法
> 2. 在我们能接受的范围内，用toFixed
> 3. 两边相减小于一个极小数， Number.EPSILON



## 37. 原码， 反码， 补码

> 最高位表示符号位， 其余位做数值位
>
> 正数的最高位为0， 原码反码补码都一样
>
> 负数的原码最高位为1， 反码最高位不变， 其他位置取反， 补码是反码加1



## XSS

> 跨站脚本攻击， 是一种代码注入攻击， 攻击者通过在网站注入恶意脚本， 使之在用户的浏览器上运行， 从而盗取用户的信息如cookie等，xss的本质是网站没有对恶意代码进行过滤，与正常的代码混合在一起， 浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。
>
> 在前端方面， xss的预防，对可能出现漏洞的地方对数据进行分析和转义， 对插入html的字符串要格外小心。



## 39. 点击劫持

> 点击劫持通过视觉欺骗， 将要攻击的网站通过iframe嵌入页面，并把iframe设置为透明， 并设置一个按钮之类的，诱导用户操作。
>
> 预防的方法是在http响应头中设置X-FRAME-OPTIONS， 规定页面在一些特定的情况下才能作为iframe来使用。



## 40. MVC, MVP, MVVM

> 三种常见的软件架构设计模式
>
> mvc: model, view, controller, model负责状态和数据管理，view负责ui， controller负责业务逻辑。 流程是， view跟model应用了观察者模式， 当model发生变化时，它会通知view进行改变， 然后当有事件之类的时候controller控制如何响应事件， 以及数据如何变化， controller中有model的接口， 所以当controller调用接口改变model后， model又会通知view。
>
> mvp：相对于mvc， 把controller改成了presenter， 主要变化就是取消了model与view之间的观察者模式， 把model数据变化时通知view更新ui这个事情也放到了presenter中， 这样就把model跟view解耦了。
>
> mvvm：vm指view-model， 相对其他两个， 把model数据改变view更新ui这个事，在view-model中，做了双向数据绑定， 意思就是model跟view中的数据做了同步。比如input的value的同步。



## 元素的各种宽高和位置

> 对于元素： 

![image-20200807203129444](/Users/LinFeng/OneDrives/OneDrive/学习工作/前端/Github/frontend-starter/面试准备/学习记录.assets/image-20200807203129444.png)

>offsetParent: 最接近的css定位的祖先
>
>offsetLeft/offsetTop: 相对于offsetParent的左上角边缘的坐标
>
>offsetWidth/offsetHeight: 包括border的大小
>
>clientLeft/clientTop: border + 滚动条
>
>clientWidth/clientHeight: 包括padding
>
>scrollWidth/scrollHeight: 内容的全部宽高；
>
>scrollLeft/scrollTop: 滚出去的内容；
>
>除了scrollLeft/scrollTop其他都是只读的， 如果我们修改scrollLeft/scrollTop, 浏览器会滚动对应的元素。
>
> 
>
>为什么不用getComputedStyle来读取css-width和height？
>
>1. box-sizing
>2. css的width、height可能是auto
>3. 不同浏览器对滚动条的处理不一样

> 文档可见部分/窗口的width,height：
>
> document.documentElement.clientWidth（不包含滚动条）
>
> 浏览器窗口的：
>
> window.innerWidth(包含滚动条)
>
> 整个文档的可靠高度：
>
> ```javascript
> let { body, documentElement } = document
> let scrollHeight = Math.max(
> 	body.scrollHeight, documentElement.scrollHeight,
>   body.offsetHeight, documentElement.offsetHeight,
>   body.clientHeight, documentElement.clientHeight,
> )
> ```
>
>   
>
> 对于整个文档的滚动：
>
> 1. 读取当前的滚动，window.pageYOffset/pageXOffset
>
> 2. 更改当前的滚动，window.scrollTo(pageX, pageY)
>
>    window.scrollBy(x, y), elem.scrollIntoView(top)

> 坐标： elem.getBoundingClientRect() 获取元素相对于视口的坐标
>
> 



## 41. window.requestAnimationFrame(callback)

> 告诉浏览器， 你希望执行一个动画， 并且希望在下次一重绘之前调用回调函数更新动画。
>
> 一秒内，回调函数执行次数通常跟屏幕刷新频率一样，当requestAnimationFrame运行在后台标签页时， 会自动暂停调用，以节能



## 42. 图片的懒加载跟预加载

> 懒加载是指当要用到的时候再去加载图片， 比如说一个图片网站有很长一列的图片， 那些还没进入视口的图片元素要等到进入视口的时候再去加载图片， 那如果用户没有向下滚动， 这些图片就不用加载， 这样子，不仅提高了页面性能，提高了首屏加载速度， 还减轻了服务器压力， 我了解的具体实现方法是 ，先将图片的src设置为空，等监控到元素进入视口， 再给src赋值。
>
> 预加载是提前去加载图片，这样子，等要用到的时候，直接从缓存中取， 这样子可以减少用户等待时间， 提升用户体验，但是会加重服务器压力 我了解到的方法是，利用js新建img元素， 给img元素的src赋值。
>
> 



## 43. mouseover, mouseout, mouseenter, mouseleave

mouseover/mouseout, 从父元素移动到子元素也会触发，且会冒泡，

mouseenter/mouseleave, 从父元素移动到子元素不会触发， 不会冒泡，





## 44. 常用的Content-Type

> 1. application/x-www-form-urlencoded, 浏览器原生的表单提交数据时使用
>
> 2. multipart/form-data, 原生表单提交文件时使用
>
> 3. application/json
>
>    [https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/](https://honglu.me/2015/07/13/常用的几种Content-Type/)



## 45. 一道js的综合考察题

https://github.com/Wscats/articles/issues/85

```javascript
function Foo(){
  getName = function() {
    alert.log(1);
  }
  return this
}

Foo.getName = function() {
  alert.log(2);
}

Foo.prototype.getName = function(){
  alert.log(3);
}

var getName = function () {
  alert.log(4);
}

function getName() {
  alert.log(5)
}

Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1
getName(); // 1
new Foo.getName();  // 2
new Foo().getName(); // 3
new new Foo().getName(); // 3
```



## 46. js 的命名规则

1. 以字母， 下划线， $ 开头

2. 余下的字符可以是，字母， 下划线， $， 数字

   

## 47. 一个列表， 假设有100000个数据， 这个该怎么办

首先要思考，处理是否要同步完成， 数据是否要按顺序加载，是否必须全部加载

1. 分页
2. 懒加载
3. 如果要全部加载也不能同时发送请求， 先对数据分组， 然后用promise一次一组的加载。



## 48. 正则

> 1. email 正则：
>
>    /^([a-zA-Z0-9\_\\-\\.]+)\@([a-zA-Z0-9\_\\-\\.]+)\.([a-zA-Z]{3, 5})$/
>
> 2. url正则
>
>    



## es6 新特性



## 设计模式





# CSS

## 1. 选择器

1. id选择器
2. 类选择器
3. 属性选择器
4. 元素选择器
5. 后代选择器
6. 相邻后代选择器（div>p)
7. 兄弟选择器(span~span)
8. 相邻兄弟选择器（span+span)
9. 伪类选择器（a:hover)
10. 伪元素选择器（a::before)
11. 通配符选择器（*）



## 2. 优先级

分4级， 分级计数， 然后按级比较， 同等级按出现顺序。important最高

1. 行内style
2. id选择器
3. 类选择器，属性选择器
4. 元素选择器， 伪元素选择器



## 3. 伪类LVHA的解释

a 标签有4中状态， 访问前， 访问后， 鼠标滑过， 激活（鼠标按下）， 分别对应:link, :visited, :hover, :active

当鼠标滑过时， a满足两种状态， :link(:visited), :hover, 要显示:hover的样式， :hover就要写在:link后面。

当鼠标按下时， a满足3中状态： :line(:visited), :hover: active, 要显示:active的样式， :active就要显示在:link, :hover的后面

所以一般按lvha的顺序写a标签的样式。其中lv的顺序可以调换，但是没必要。



## 4. css3新增伪类

> 1. :nth-child
> 2. :nth-last-child
> 3. :nth-type
> 4. :last-child
> 5. :first-child
> 6. :not(elem)
> 7. :first-of-type
> 8. :last-of-type
> 9. 等



## 5. 居中总结

> 1. 行盒，行块盒水平居中： text-align: center
> 2. 常规流块盒水平居中： 定宽， margin: 0 auto;
> 3. 绝对定位，固定定位水平居中： 定宽， left=0, right=0, margin: 0 auto;
> 4. 单行文本垂直居中： line-height = height;
> 5. 绝对定位，固定定位垂直居中： 定高， top=0, bottom=0, margin: auto 0;
> 6. 绝对定位， 固定定位元素， left = 50%, top = 50%, 然后利用margin负值调整元素位置。达到居中， 适用于元素定宽高
> 7. 绝对定位， 固定定位元素，left = 50%, top = 50%, 利用translate居中， 可以不用定宽高
> 8. 利用flex布局，设置align-items:center, justify-content:center, 来达到交叉轴方向，跟主轴方向的元素的居中。



## 6. display的属性值

> 1. block，块盒， 默认宽度为父元素宽度， 可设置宽高， 换行
> 2. inline，行盒， 默认宽度为内容宽度， 不可设置宽高，
> 3. inline-block, 行块盒， 默认宽度为内容宽度， 可设置宽高
> 4. none；从文档流中移除，不显示
> 5. list-item， 块盒，并添加列表样式
> 6. table， 该元素会作为块级表格来显示
> 7. inherit， 从父元素继承



## 7. display:none, visibility: hidden, opacity: 0

> display:none, 从文档流移除，不占据空间， 无法点击
>
> visibility:hidden, 占据空间， 无法点击
>
> opacity:0, 占据空间， 可以点击



## 8. 定位

> relative: 根据元素本身正常位置来定位
>
> absolute: 根据第一个position不为static的祖先元素定位， 定位原点是该祖先元素的padding-box的左上角。
>
> fixed： 根据视口左上角定位。



## 9. flex

> flex是css3新增的一种布局方式， 通过将元素的display值设置为flex从而将元素变成一个flex容器， 设置了该属性后， 子元素上的float， vertical-align， clear等属性会失效， 该元素的子元素我们称之为flexitem， 下面简称item， 在容器元素上还可以定义一些flex相关属性：
>
> 1. flex-direction， 设置主轴方向
> 2. flex-wrap，设置当主轴放不下子元素时的换行方式
> 3. justify-content，设置主轴的item的对齐方式
> 4. align-items， 设置交叉轴的item的对齐方式
> 5. align-content， 设置多根轴线的对齐方式
> 6. flex-flow: flex-direction, flex-wrap的简写属性， 默认值为row nowrap
>
> 在item上的flex相关属性有：
>
> 1. flex-grow， 当有剩余空间时， item的放大比例
> 2. flex-shrink： 当剩余空间不足时， item的缩小比例
> 3. flex-basis: 定义了，在分配剩余空间时， item占据的主轴空间
> 4. flex： flex-grow，flex-shrink，flex-basis的缩写， 默认值为0 1 auto。
> 5. align-self，使item能脱离flex容器的align-items中的对齐控制， 使用自己的对齐方式。



## 10. BFC

> Block Formatting Context, 一块独立的渲染区域，规定了在该区域内常规流块盒的布局
>
> 1. 常规流块盒在水平方向上，撑满包含块， 在垂直方向上依次摆放，
> 2. 常规流块盒margin若无缝相邻， 则合并
> 3. 常规流块盒摆放时无视浮动元素
>
> 各个bfc相互独立， 其内部元素的渲染不会影响到外面，创建bfc的元素还有如下几个特点
>
> 1. 自动高度需要计算浮动元素
> 2. margin不会与子元素的margin合并
> 3. border-box不会与浮动元素重叠，也就是会避开浮动元素。
>
> 创建bfc有如下几种办法：
>
> 1. 根元素自动bfc
> 2. float， 绝对定位， 固定定位元素
> 3. display: flex, grid, table相关，inline-block,
> 4. overflow 不为 visible;



## 布局

### 1. 品字布局

> div都设置为width： 50%；
>
> 上面的用margin： 0 auto
>
> 下面的两个用float或者inline-block，用inline-block会有个问题就是inline-block间的间隙， 所以还是用float吧

```html
    <style type="text/css">
      * {
        margin: 0;
        padding: 0;
      }
      html,
      body {
        width: 100%;
        height: 100%;
      }
      .num1 {
        width: 50%;
        height: 50%;
        margin: 0 auto;
        background: red;
      }
      .row2 {
        height: 100%;
      }
      .num2 {
        width: 50%;
        height: 100%;
        float: left;
        background: green;
      }
      .num3 {
        width: 50%;
        height: 100%;
        float: right;
        background: blue;
      }
    </style>

  <body>
    <div class="num1"></div>
    <div class="row2">
      <div class="num2"></div>
      <div class="num3"></div>
    </div>
  </body>
```



> 用grid布局



``` javascript
  <style type="text/css">
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html,
    body {
      width: 100%;
      height: 100%;
    }
    .wrapper {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(2, 1fr);
      width: 100%;
      height: 100%;
    }
    .c1 {
      grid-column: 2/4;
      grid-row: 1;
      background: red;
    }
    .c2 {
      grid-column: 1/3;
      grid-row: 2;
      background: blue;
    }
    .c3 {
      grid-column: 3/5;
      grid-row: 2;
      background: green;
    }
  </style>
  <body>
    <div class="wrapper">
      <div class="c1"></div>
      <div class="c2"></div>
      <div class="c3"></div>
    </div>

  </body>
```



### 2. 多列等高布局

```html
<ul class="Article">
  <li class="js-article-item">
    <p>
      一家将客户利益置于首位的经纪商，
      为客户提供专业的交易工具一家将客户利益置于首位的经纪商，
      为客户提供专业的交易工具一家将客户利益置于首位的经纪商，
      为客户提供专业的交易工具一家将客户利益置于首位的经纪商，为客户提供专业的交易工具
    </p>
  </li>
  <li class="js-article-item">
    <p>
      一家将客户利益置于首位的经纪商，为客户提供专业的交易工具
      一家将客户利益置于首位的经纪商，为客户提供专业的交易工具
    </p>
  </li>
  <li class="js-article-item">
    <p>一家将客户利益置于首位的经纪商</p>
  </li>
</ul>
```





> 用padding-bottom跟margin-bottom对冲
>
> ```javascript
> .Article {
>   list-style: none;
>   overflow: hidden;
> }
> .Article li {
>   float: left;
>   width: 200px;
>   padding-bottom: 9999px;
>   margin-bottom: -9999px;
>   margin-right: 10px;
>   background: blue;
> }
> ```
>
> 



> 用table， table-cell默认等高
>
> ```javascript
> .Article {
>   display: table;
> }
> .Article li {
>   display: table-cell;
>   width: 200px;
>   border-right: 10px solid white;
>   background: blue;
> }
> ```
>
> 

> 用flex
>
> ```javascript
> .Article {
>   display: flex;
>   list-style: none;
> }
> .Article li {
>   flex: 0 0 200px;
>   background: blue;
>   margin-right: 10px;
> }
> ```
>
> 



> 用grid
>
> ```javascript
> .Article {
>   display: grid;
>   list-style: none;
>   grid-template-areas: "a b c";
>   grid-gap: 10px;
> }
> .Article li {
>   width: 200px;
>   background: blue;
> }
> .Article li:nth-child(1) {
>   grid-area: "a";
> }
> .Article li:nth-child(2) {
>   grid-area: "b";
> }
> .Article li:nth-child(3) {
>   grid-area: "c";
> }
> ```
>
> 



### 3. 两列自适应布局

> 两列自适应布局，是指一列由内容撑开，另一列撑满剩余宽度的布局方式。
>
> 1. 左侧float， 右侧overflow：hidden, 原理就是overflow:hidden触发bfc
> 2. flex布局，右侧设置flex：1.



### 4. 三栏布局

> 中间列自适应宽度， 旁边两侧固定宽度
>
> 如果还要求， dom结构必须是中间先写， 这样子中间列可以优先加载。
>
> 按实现方式分为：圣杯布局， 双飞翼布局， flex的实现。

> 圣杯布局
>
> ```html
> <style type="text/css">
>   .container {
>     padding-left: 220px;
>     padding-right: 220px;
>   }
>   .left {
>     float: left;
>     width: 200px;
>     height: 400px;
>     background: red;
>     margin-left: -100%;
>     position: relative;
>     left: -220px;
>   }
>   .center {
>     float: left;
>     width: 100%;
>     height: 500px;
>     background: yellow;
>   }
>   .right {
>     float: left;
>     width: 200px;
>     height: 400px;
>     background: blue;
>     margin-left: -200px;
>     position: relative;
>     right: -220px;
>   }
> </style>
> 
> <article class="container">
>   <div class="center">
>     <h2>圣杯布局</h2>
>   </div>
>   <div class="left"></div>
>   <div class="right"></div>
> </article>
> ```
>
>  
>
> 步骤
>
> 1. 3栏都float：left
> 2. center， 宽度占满，left设置margin-left: -100%, right设置margin-left: -200px;
> 3. container设置padding，left跟right通过相对定位调整位置。

> 双飞翼布局
>
> ```html
> <style type="text/css">
>   .container {
>     min-width: 600px;
>   }
>   .left {
>     float: left;
>     width: 200px;
>     height: 400px;
>     background: red;
>     margin-left: -100%;
>   }
>   .center {
>     float: left;
>     width: 100%;
>     height: 500px;
>   }
>   .center .inner {
>     margin: 0 200px;
>     background: yellow;
>   }
>   .right {
>     float: left;
>     width: 200px;
>     height: 400px;
>     background: blue;
>     margin-left: -200px;
>   }
> 
> </style>
> 
> <article class="container">
>   <div class="center">
>     <div class="inner">双飞翼布局</div>
>   </div>
>   <div class="left"></div>
>   <div class="right"></div>
> </article>
> ```
>
>  
>
> 前两步跟圣双杯差不多， 只不过对center的内容多包了一层，通过调整inner来为两侧留白。

> 圣双杯布局与双飞翼比较
>
> 1. 两种布局都是将主列放在文档流最前面，使主列优先加载。
> 2. 实现方式的相同方面是都是使三栏浮动， 不同之处是，为两侧留白的方式不同，圣双杯的方式是通过调整父容器的margin+两侧的相对定位实现， 双飞翼的方式是使主列的内容新增一层wrapper， 然后调整wrapper的margin来为两侧留白。

> flex的实现
>
> 通过调整css的order属性
>
> ```javascript
> html, body {
>   width: 100%;
>   height: 100%;
> }
> .container {
>   display: flex;
> }
> .left {
>   width: 200px;
>   order: 1;
> }
> .center{
>   flex: 1;
>   order: 2;
> }
> .right {
>   width: 200px;
>   order: 3;
> }
> ```
>
> 



### 5. 粘连布局

![粘性布局](/Users/LinFeng/OneDrives/OneDrive/学习工作/前端/Github/frontend-starter/面试准备/学习记录.assets/粘性布局.png)



> 有两部分内容， main， 跟footer， 当main高度够长时， footer跟在main后面， 当main较短时， footer粘在视口底部。实现方式， 为main套一层wrapper,其min-height:100%.其他元素注意调整位置
>
> ```html
> <style type="text/css">
>   * {
>     margin: 0;
>     padding: 0;
>   }
>   html,
>   body {
>     height: 100%;
>   }
>   #wrap {
>     min-height: 100%;
>   }
>   #wrap .main {
>     padding-bottom: 50px;
>   }
>   #footer {
>     height: 50px;
>     margin-top: -50px;
>   }
> </style>
> 
> <div id="wrap">
>   <div class="main">
>     Lorem ipsum dolor sit amet consectetur adipisicing elit. Repellendus,
>     odio?
>   </div>
> </div>
> <div id="footer">footer</div>
> ```
>
> 



### 18.li与li之间有看不见的空白间隔是什么原因引起的？解决办法是什么

> 浏览器会把inline元素之间的空白字符(空格， 换行， tab等)渲染成一个空格， 为了美观。我们通常是一个li一行， 所以之间会有空白字符。
>
> 解决方法：
>
> 1. li连着写， 这样代码不美观
> 2. li， float：left，影响布局
> 3. 设ul的font-size:0, li的font-size改回来。
> 4. 修改ul的字符间隔， letter-spacing：为负值比如-8px， li的letter-spacing为normal。



### 19. 包含块

> 包含块就是元素用来计算定位的一个框
>
> 1. 根元素被称为初始包含块， 其尺寸等同于视口大小
> 2. 对于其他元素，如果该元素的position为relative， 或者static， 则其包含块为其父元素的content-box
> 3. 对于position为fixed的， 其包含块为初始包含块
> 4. 对于position为absolute的， 其包含块为其最近的position不为static的祖先元素的padding-box。



### 20. width: 100% 跟 width: auto的区别

> width:100% 使元素的content-box 的宽度始终与其父元素的content-box一致。
>
> width: auto使元素的content-box的宽度自适应， 元素的margin-box宽度与其父元素的content-box宽度一致



### 21.background的范围

> border-box



### 22.margin合并/重叠问题

> 垂直方向的margin有时会合并成为单个外边距， 这样的现象称为’margin合并’
>
> 产生合并的必要条件是，margin是无缝接触的。根据w3c规范， 所谓无缝接触要满足下列条件：
>
> 1. 处于同一个bfc中的块级盒子
> 2. 没有线盒，空隙，padding， border将它们分开
> 3. 垂直方向上相邻的外边距
>
> 解决margin合并的方法，按情况来划分：
>
> 1. 相邻兄弟元素的margin合并： 其中一个包上一个触发bfc的div
> 2. 父元素与子元素的margin合并：父元素触发bfc/设置border,padding/用空inline-block隔开(inline,block不管用， inline-block会触发bfc)/用父元素的padding代替子元素的margin



### 23. 绝对定位元素与非绝对定位元素的百分比计算

> 百分比都是相对其包含框
>
> 包含框见19



### 24.base64编码的优点和缺点

> 优点：减少http请求
>
> 缺点： 编码后比原图片大1/3，如果把比较大的图片做base64放到html里，会影响文件加载速度， ie8之前的浏览器不支持。

### 25.IFC, 行级格式化上下文，

> IFC指的是行级格式化上下文，它有这样的一些布局规则
>
> 1. 内联元素在水平方向上一个接一个的放置
> 2. 高度取决于该行中最高的盒子的高度
> 3. 当一行放不下时自动换行



### 26. 浮动是什么？

> 浮动的元素， 布局时脱离常规流， 根据设置， 会向左或者向右移动，到遇到其他浮动元素或者包含框的边框才会停下。
>
> 当元素浮动后， 不会影响块盒的布局， 但是会影响内联元素的布局。元素浮动后还会导致其包含框的高度塌陷， 高度塌陷是指，自动高度的情况下，父元素高度的计算会忽略浮动元素的高度。解决高度塌陷的方法统称为清除浮动。
>
> 清除浮动有以下几种方法：
>
> 1. 使用clear属性, 一个元素指定了clear属性，比如说clear:left, 代表该元素必须出现在它前面的左浮动元素的下方。一般使用父元素的伪类after， 设置其clear为both，dispaly为block（clear属性只有在块盒上有效), 就能较好的解决问题。
> 2. 父元素触发bfc。



### 27.媒体查询



### 28. sass

> 一个css预处理器， scss更加简洁， 适应性更强，可读性更强， 可嵌套，可使用变量， 支持计算属性值等。



### 29. css性能优化

> 我了解的有以下几点
>
> 1. 打包压缩css
> 2. 使用单一样式，不要使用复合样式，如使用margin-top，不要使用margin
> 3. 选择器尽量又精准又短， 避免嵌套过深。
> 4. 减少使用高性能属性，浮动，定位等。
> 5. 尽量不要使用通配符 * ，因为这样需要把所有标签都遍历一遍。



### 30.抽离样式模块怎么写，说出思路，有无实践经验？

> 我了解到的抽离样式的思路是，将css样式的功能分为如下几类：
>
> 1. reset
> 2. 公用型样式，比如布局样式，元件样式， 函数样式等
> 3. 皮肤型样式，比如实现换肤功能的时候， 将颜色，背景等抽离出来
> 4. 特殊型的样式，就是指上面的样式无法满足需求时需要额外编写的样式
>
> 个人实践中，自己去做抽离会比较上，只用到reset， 还有调用一下css框架， 比如antd时会了解到一点。



### 31. 字体的大小， 应该使用奇数还是偶数？ 为什么

> 个人认为使用偶数会更好一点， 偶数字号更容易和其他部分构成比例， 而且兼容性好。



### 32. margin和padding分别时候什么场景使用

> margin适用于隔开元素
>
> padding适用于将元素与其内容隔开。



### 33. 元素的竖向百分比

> 如果是height的话，相对的是包含块的高度
>
> 如果是padding或者margin的垂直方向的属性的话，相对的是包含块的宽度。



### 34. 响应式布局

> 响应式布局是指使一个页面能够适应多个终端，而不是为每个终端都单独做一个页面， 基本原理是通过媒体查询为不同的终端设计不同的布局方案



### 35.如果需要手写动画， 你认为最小时间间隔是多久，为什么？

> 多数显示器默认频率是60hz， 即1秒刷新60次，所以理论上最小间隔为1/60 * 1000ms = 16.7ms



### 36.如何去除inline-block元素间的间距

> 移除空格， 使用margin负值， fong-size:0, letter-spacing负值，



### 37.雪碧图

> 将一些小图片， 整合到一张图片中， 然后利用css的background相关属性显示需要的小图片
>
> 优点：
>
> 减少http请求，更换风格方便
>
> 缺点：
>
> 图片合并麻烦， 维护麻烦。



### 38. dpr, css像素，物理像素， layout-viewport, visual-viewport, ideal-viewport. em, rem,px

> px, em, rem
>
> 在js，或者css中，写下的px代表的是css像素， em是根据当前元素的字体大小来换算成px,1em=1curfontsize, rem为根元素的font-size， 1rem=1root-fontsize
>
> dpr,css像素， 物理像素
>
> 物理像素，即屏幕的真实像素点
>
> dpr代表用多少个物理像素来表示一个css像素， dpr=2， 代表用4个物理像素来表示一个css像素
>
> 由于不同设备的dpr不一样， 而我们js，css写的是css像素， 所以会导致在不同设备上的显示差异。
>
> layout-viewport, visual-viewport, ideal-viewport
>
> 由于移动设备上的宽度一般较小， 所以为了使得为桌面设计的页面也能在移动端正常显示， 推出了layout-viewport概念，它的宽度一般比移动设备的屏幕宽度大。然而，我们还需要一个可以得知可视窗口的宽度的办法， 于是就有了visual-viewport的概念。但是浏览器们觉得还不够，因为越来越多网页会针对移动端单独设计，所以还需要一个完美适配移动设备的viewport，所谓完美适配是指用户不需要缩放，或者横向滚动条就能正常查看网页内容， 称这样的viewport为ideal-viewport，它的宽度根据设备变化。
>
> 设置ideal-viewport的方法
>
> \<meta name=‘viewport’ content=‘width=device-width’ /\>



### 39.什么是cookie隔离

> 浏览器向同源url请求时， 会带上cookie这样增加表头信息量，使请求变慢
>
> 对于静态资源的请求携带cookie就没必要
>
> 解决办法， 将静态资源放到域名上， 一般静态资源会使用cdn。



### 40. animation, transition, translate, transform

> animation用来控制由@keyframes 定义好的动画的其他属性， 如name, duration, timing-function, delay, iteration-count,direction,play-state等
>
> transition: 用来设置元素的样式过渡，就是控制元素某个属性值变化时，控制变化过程的过渡效果
>
> transform： 用于对元素进行旋转，缩放，移动，倾斜等调整。translate是transform的一个属性值，即移动。



### 41. 为什么height： 100%无效

> 对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值
>
> 



### 42. min-width/max-width属性间的覆盖规则

> 1. max-width会覆盖width，即使width是行内样式或者设置了!important
> 2. 当min-width跟max-width冲突时， min-width覆盖max-width



### 43. 什么是替换元素， 替换元素的宽高计算规则

> 通过修改某个属性值其呈现的内容就可以被替换的元素就称为替换元素。因此，<img>, <object>,<video>, <iframe>或者表单元素<input>, <textarea>, <select>都是典型的替换元素。
>
> 替换元素除了内容可以替换这一个特性外， 还有以下的特性。
>
> 1. 内容的外观不受页面上的css的影响。2。有自己的尺寸。3.替换元素都是内联元素
>
>  
>
> 替换元素的宽高计算规则
>
> 有三种尺寸需要考虑到，1.固有尺寸，如图片原本的尺寸，2，html尺寸，这里指浏览器的默认样式，3.css尺寸，这里指我们用css指定的宽高。这三种样式的优先级为css>html>固有， 当高优先级的尺寸缺失时，就去找低优先级的尺寸。
>
> 还有就是宽高比例。如果固有尺寸含有宽高比例， 且仅设置了宽度或仅设置了高度， 则保持原有宽高比例。
>
> 





### 44. 层叠上下文，层叠水平

> 绝定了，当元素发生重叠时， 谁覆盖谁。 
>
> 1. 层叠水平大的覆盖层叠水平低的
> 2. 层叠水平相同的。在文档流中靠后的覆盖靠前的。
>
> 层叠上下文作为一个整体进行层叠。
>
> 层叠上下文的创建：
>
> 1. 根元素天生具有层叠上下文
> 2. 绝对定位，固定定位的



### 45.letter-spacing跟word-spacing

letter-spacing用来控制字符之间的间距， word-spacing用来控制空格字符的宽度。



### 46. white-space

声明了如何处理元素内的空白字符。例如当需要显示代码时， 可以调整white-space为pre，来显示连续空白字符。white-space:nowrap代表不换行。



### 47. 单行文本溢出

> p{
>
>   overflow:hidden;
>
>   text-overflow: ellipsis;
>
>   white-space: nowrap;  不换行
>
> }



### 48.三角形与正方形

> 三角形
>
> ​      .box {
>
> ​        width: 0;
>
> ​        height: 0;
>
> ​        border-width: 100px;
>
> ​        border-style: solid;
>
> ​        border-color: transparent transparent red transparent;
>
> ​      } 
>
>  
>
> 正方形
>
> 1. 利用vw
>
> ​      .box {
>
> ​        width: 10vw;
>
> ​        height: 10vw;
>
> ​        background: red;
>
> ​      }
>
> 2. 利用padding的百分比是相对于包含块的width的。
>
>    ​      html,
>
>    ​      body {
>
>    ​        width: 100%;
>
>    ​        height: 100%;
>
>    ​      }
>
>    ​      .box {
>
>    ​        width: 10%;
>
>    ​        height: 10%;
>
>    ​        background: red;
>
>    ​      }



## 49. 浏览器内核css前缀

firefox: -moz

chrome: -webkit

ie: -ms





## css3 新特性





# React

 ## 1. react事件和dom事件的区别

react事件是合成的事件， event.nativeEvent是原生的事件对象，所有的事件都被挂载到document上



## 2. 为什么react把事件都挂到document上





## 3. 受控组件/非受控组件

受控组件， 内容变化跟state有关

必须操作dom时， 再使用非受控组件

非受控组件使用场景：

上传文件， 富文本编辑





## 4.父子组件通讯

props传递属性，函数， 



## 5. setState

1.不可变值

2. 可能异步更新， 在setTimeout中是同步， 在事件回调中是同步
3. 可能合并，（传对象会被合并， 传函数会一个一个执行）



## 6. 生命周期

单个组件生命周期

^16.4

Mounting: constructor--getDrivedStateFromProps—render—componentDidMount

Updating: new props, setState, forceUpdate — getDrivedStateFromProps — shouldComponentUpdate — render — getSnapshotBeforeUpdate — componentDidUpdate

Unmounting: componentWillUnmount



父子组件生命周期

创建组件阶段：

父组件：constructor — render 

子组件: constructor — render — componentDidMount

父组件：componentDidMount



更新阶段：

父组件：getDrivedStateFromProps — shouldComponentUpdate — render 

子组件：getDrivedStateFromProps — shouldComponentUpdate — render — componentDidUpdate

父组件： componentDidUpdate



卸载阶段：

父组件： componentWillUnmount

子组件： componentWillUnmount



## 7. 函数组件

1.纯函数，没有副作用， 输入props，输出jsx

2.没有实例，没有生命周期， 没有state



## 8. Portals

提供了把子组件渲染到父组件之外的dom节点的方法。但是虽然渲染到了外面， 但是在子组件的事件，还是会冒泡到父组件。

```javascript
return ReactDOM.createPortal(
	this.props.children,
  domNode
)
```



使用场景：

1. 父组件限制了子组件的渲染，子组件需要逃离父组件。比如父组件z-index太小
2. fixed需要放到body，为了兼容问题。



## 9. context

1. 公共信息（语言，主题）如何传递给每个组件？
2. 用props太繁琐
3. 用redux小题大做

```javascript
const ThemeContext = React.createContext(defaultValue)

<ThemeContext.Provider value={someValue}></ThemeContext>

<ThemeContext.Consumer>{(value) => ...}</ThemeContext.Consumer>

SomeClass.contentType = ThemeContext
在someClass内部使用this.context访问
```



## 10.异步组件

```javascript
const Demo = React.lazy(() => import('./Demo'))

<React.Suspense fallback={<div>Loading...</div>}>
     <Demo />
 </React.Suspence>
```



react-loadable



## 11. react性能优化

1. shouldComponentUpdate(nextProps, nextState){}
2. PureComponent, React.memo
3. immutable

> shouldComponentUpdate
>
> 默认返回true，返回true允许重新渲染， 返回false不允许重新渲染
>
> 为什么react要提供这么一个功能？
>
> 1. react里面， 只要父组件更新，子组件默认也要更新， 不管子组件的数据有没有变化
> 2. 
>
> 

> PureComponent的SCU默认实现了浅比较。
>
> memo， 函数组件中的PureComponent, 为传入函数组件的props默认提供了浅层比较
>
> ```javascript
> function MyComponent(props){}
> function areEqual(prevProps, nextProps){}
> 
> const MyComponentMemo = React.memo(MyComponent[, areEqual])
> ```

> immutable.js
>
> 1. 彻底拥抱’不可变值’
> 2. 基于共享数据（不是深拷贝），速度好
> 3. 按需使用



## 12.关于组件公共逻辑的抽离

> mixin, 已被React弃用
>
> 高阶组件HOC, 把公共逻辑放在HOC里面， 对低阶组件进行包装，方式一般是通过props传值
>
> Render Props的核心思想， 通过一个函数将class组件的state作为props传递给纯函数组件， 干的事跟hoc差不多，就是实现不一样。



## 13.redux

数据流

dispatch(action) — reducer— newState — subscribe — 触发通知











# HTML 

## 1. 什么是重绘和回流

> 重绘： 当一些元素需要更新属性， 而这些属性只是影响元素外观， 风格，不影响布局，这样的操作称为重绘
>
> 回流： 元素的属性更改，影响了布局，比如更改了尺寸， 位置等， 这样的操作称为回流
>
> 回流必定会发生重绘， 重绘不一定会引发回流。



## 2. 如何减少回流

> 尽量不要一条一条的更改属性值， 可以预先定义好class， 然后修改元素的class，
>
> 不要使用table布局， 因为其中一个很小的改动都有可能导致table的重新布局



## 3. 为什么操作dom慢

一些dom的操作或者属性值的更改会引起页面的回流和重绘， 从而引起性能上的消耗



## 4. DOMContentLoaded 和 Load的区别

当dom元素加载和解析完成后触发DOMContentLoaded的事件， 无需等待样式表和图片等的加载

当页面所有资源加载完成后， 触发load事件



## 5. html5新特性

video, audio, localStorage, sessionStorage, 

一些语义化更好的内容元素， article, footer, header, nav, section;

表单控件： calendar, date, time, email, url, search;



## 6. 对html语义化的理解

我认为html语义化的意思是，用适当的标签来划分网页内容， 使得html不仅对开发人员来说更容易阅读， 对机器来说也会共容易阅读。对开发人员来说， 可以通过标签来辅助判断不同区域的功能和作用。对机器来说，利于爬虫理解网页， 从而有利于seo，而且从无障碍方面考虑， 也更人性化，比如b标签和strong标签在显示效果上都是对文字加粗， 但是strong还带有强调的语义。



## 7. 提高seo

1. 语义化的html代码
2. 重要的内容往前写，因为有些爬虫对抓取长度有限制， 需要保证重要内容被抓取
3. 重要的内容不要用js输出， 爬虫不会执行js获取内容
4. 非装饰性的图片最好加alt
5. 提高网站速度，网站速度是搜索引擎排序的一个重要指标



## 8. 常见的浏览器端的存储技术有哪些

cookie，localStorage，sessionStorage, 

indexDB用于大规模数据存储



## 9. cookie, localStorage, sessionStorage

浏览器端常用的存储技术是cookie, localStorage, sessionStorage

cookie, 一般用来保存用户状态，和那些需要在每次发起请求都要发送个服务端的数据。每个cookie最多存4kb数据，cookie的数量一般是20条， 但是具体看浏览器

localStorage，html5提供的浏览器本地存储方法， 一般能存5m或者更大的数据，能够在同源页面间共享， 而且浏览器关闭，数据也不会消失

sessionStorage，与localStorage相似， 但是它在窗口关闭后就消失， 而且只能在同一窗口内共享



## 10. label的作用

label标签用来定义表单控件的标签， 当用户选择该标签时，会自动将焦点转移到相关的控件上



## 11. html5的form的自动完成功能是什么？

autocomplete 属性规定输入字段是否应该启用自动完成功能，默认为启用。

启用后，当用户输入时，会根据之前输入过的值，显示可选项。



## 12. 如何实现浏览器内多个标签页通信

1. 用webSocket， 通信的标签连接同一个服务器， 用服务器作为中介
2. 使用localStorage在同源页面间通信， 当localStorage被修改时， 会触发storage事件， 可以通过监听它的值来进行页面信息通信



## 13. title与h1的区别

title就只包含标题的意思，h1则额外带有层次



## 14. img 的title和alt的区别

title通常当鼠标滑动到元素上的时候显示

alt是图片内容的等价描述， 当图片显示异常的时候， 用来替代。而且搜索引擎会分析alt



## 15. 网站验证码的作用

1. 区分用户是计算机还是人，以防攻击



## 16. 渐近增强和优雅降级的定义

渐近增强： 针对低版本浏览器进行构建页面， 保证最基本的功能， 然后再针对高级浏览器进行页面升级

优雅降级：先根据高级浏览器构建完整的功能， 然后再针对低版本浏览器进行兼容



## 17. attribute, property的区别是什么

attribute指的是html标签拥有的属性

property值的是js中dom对象拥有的属性

对于标准的html属性，两者是同步的，对于自定义的属性， 两者是不同步的。 



## 18. reset和normalize的区别

reset是最早的一种解决浏览器间样式不兼容问题的方案， 基本思想是把浏览器的默认样式都重置掉，从而达到所有浏览器样式保持一致的效果。

normalize是后面出现的另外一种解决浏览器不兼容的方法， 它的思想是尽可能的保留浏览器自带的样式， 通过在原有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。



## 19. 预格式化文本的标签是什么

\<pre> 使得文本以预格式化的样子输出， 所见即所得



## 20. head标签中必不可少的是

title



## 21. disable和readonly的区别

disable指的是禁用此元素，input内容不会随着表单提交

readonly指的是只读， input内容会随着表单提交





# webpack



# git





# 网络

[https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/计算机网络/计算机网络.md)

https://juejin.im/post/6844903662838349838#heading-1

常见问题:

> tcp的三次握手, 4次挥手
>
> https://blog.csdn.net/qzcsu/article/details/72861891
>
> 在浏览器中输入url地址到显示主页的过程 
>
> https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#6-%E5%BD%93%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-googlecom-%E5%B9%B6%E4%B8%94%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88
>
> http和https的区别
>
> http存在安全问题, http被人劫持后, 由于http是明文发送的, 劫持方可以知道内容, 还可以修改内容, 而接收方还没有办法确认自己收到的内容是否被劫持且修改过.https基于http协议, 使用TSL/SSL协议, 旨在解决安全问题.怎么做到的呢, 就是通过tsl的四次握手过程, 确认双方的身份,和数据加密方式.首先...
>
> http消息结构：
>
> 客户端：
>
> 1. 请求行：请求方法， url， 协议版本
> 2. 请求头
> 3. 空行
> 4. 请求数据
>
> 服务端：
>
> 1. 状态行： 协议版本， 状态码， 转态消息
> 2. 消息报头，
> 3. 空行
> 4. 响应正文
>
> tcp, udp协议的区别
>
> udp是无连接的传输层协议,之所以说是无连接的,是因为它不像tcp有一个三次握手的过程来建立可靠的链接, 所有也就少了建立链接的时延, udp只尽力交付数据,但不保证数据的可靠交付,而且没有拥塞控制和流量控制, 所以udp报文段的发送速率没有限制, udp的套接字只使用目的地址和目的端口来标识, 所以udp可以支持一对一, 一对多, 多对一, 多对多的交互通信, udp首部只有8个字节, udp适用于对实时性要求高的应用场景.
>
> tcp是有连接的,提供可靠的数据传输服务的传输层协议, tcp协议通过序号,确认号, 定时重传, 检验和等机制, 来提供可靠的数据传输服务, tcp只能一对一, tcp是全双工的, tcp有拥塞控制和流量控制,用来限制发送方发送数据的速率, 
>
> 常见的状态码
>
> 1代表服务器接收到请求, 2代表成功, 3代表重定向, 4代表客户端方面的错误, 5代表服务端方面的错误
>
> 200:请求成功,一般用于get和post请求
>
> 202:服务器已经接收到请求消息, 但是尚未处理完成
>
> 301: 永久移动,请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
>
> 302: 临时移动
>
> 304: 所请求的资源未修改,所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
>
> 400: 客户端请求语法错误
>
> 403: forbidden, 服务端理解客户端的请求, 但是拒绝执行
>
> 404: 请求的资源不存在
>
> 500: 服务器内部错误







## tcp

三次握手与4次挥手:

https://blog.csdn.net/qzcsu/article/details/72861891

**SYN**：同步序列编号（Synchronize Sequence Numbers）。 是TCP/IP建立连接时使用的握手信号。

*ACK* (Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误

FIN: Final

三次握手时, seq=x的x是客户端随机选择的后面的包要发送的序列号的开头号码



